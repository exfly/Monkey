# 执行策略

无论哪一种语言实现，执行这一部分是实现解释器过程中变化最多的部分。当执行源代码的时候，有很多不同策略的以供选择。现在我们手边已经有了抽象语法树（`AST`），那么问题来了，接下来我们需要做什么，如果去计算这棵树？接下来看看不同的观点。

在开始之前，值得注意的是解释器和编译器的界限非常模糊，往往来讲，解释器离不开可执行的环境，与之相反编译器可以脱离执行环境，而且解释器没有现实中高级优化的编程语言那么快。

经典的处理抽象语法树的方法就是解释它，遍历整个语法树，访问树中每个节点，计算出每个节点的意义，比如输出字符串，加两个数字，执行一个函数体等等。解释器这种工作方式也叫做**树的遍历**，这也是解释器的原型。有时候在执行的过程中也做一些优化处理，来重写抽象语法树（比如移除未使用的变量）或者将其改变成另一种中间表示形式，对于递归或者循环非常适用。

其他解释器同样遍历整个抽象语法树，与解释抽象语法树本身不同，它们首先将其转换成字节码。字节码同样也是抽象语法树的中间表现形式。这样的特定的格式代码各式各样，主要取决于前端和宿主机的编程语言。这种中间代码与汇编语言非常相似，可以肯定的是这样的字节码中包含的 `push` 和 `pop` 等相关栈操作符。但是字节码不是原生的机器码或者汇编语言。它不能被操作系统直接执行，`CPU` 也不能解释运行。它仅仅能够被虚拟机解释，它也是一个解释器，就跟 `VMWare` 和 `VirtualBox` 一样模拟真正的机器和 `CPU`。虚拟机是一个能理解这个特定的字节的机器，这样处理方式在性能上能够提供很好的性能上的有时。

这样不同的策略一定不影响抽象语法树，除了构建一棵抽象语法树，然后解析器直接生成字节码，那么是否还是我们仍然还在套路你的解释器或者编译器？难道生成字节码然后解释它（准确的讲叫执行）不是一种编译的形式？我想说明的是：解释器和编译之间的界限非常模糊，甚至令人感到困惑。在一些编程语言中是这样解析源代码的，构建抽象语法树，然后将抽象语法树转换成字节码。但不是在虚拟机上执行生成的字节码，而且将虚拟机的字节码编译成原生的机器码，这个过程在运行之前完成，这种方式叫做 `JIT` 解释器或者编译器。

选择哪一种策略很大一部分取决于性能和可移植性的需要，以及你想要让这个语言如何被解释。遍历整个语法树和递归去执行可能是其中最慢的一种，但是很容易去构建、拓展以及提高可适配性。

将代码转换成字节码的编译器在处理字节码时候非常快，但是创建这种编译也会变得非常复杂和困难。将 `JIT` 转换成混合模式也需要支持不同的计算机体系结构，因为需要让解释器同时运行在 `ARM` 和 `x86` 结构的 `CPU` 上。

以上所有的实现方法在现实的编程语言都能找到，大部分时候实现方式随着编程语言的发展改变而改变， `Ruby` 就是这样的例子，在 `1.8` 以及之前的版本，`Ruby` 的解释器是遍历树，边遍历边抽象语法树边执行，但是从 `1.9` 版本之后开始变成虚拟机架构，现在 `Ruby` 解释器解析源代码，构建抽象语法树后将抽象语法树编译成字节码，并在虚拟机中执行，这样在性能上有了很大的提高。

`WebKit Javascritpt` 的引擎 `JavaScriptCore` 和 `Squirrelfish` 同样也是采用抽象语法树遍历和执行的方式，在 `2008` 年后它转向了虚拟机和字节码解释执行。现在该引擎拥有是 `4` 不同阶段的 `JIT`  编译，这些都是为了在性能上提高做出的改变。

另一个例子就是 `Lua`，主要实现方式将其编译成字节码，然后在寄存器为基础的虚拟上执行，在 `12` 年后，`LuaJIT` 作为另一种实现方式出现了，作者 `Mike Pall` 的目标是创建一个尽可能快的 `Lua` 编译器，事实上同样如此，通过 `JIT` 的方式将繁琐的字节码格式转换成不同基础架构的机器码。从各个性能测试上来看，`LuaJIT` 比原生的 `Lua` 解释器要快，而且不是快一点点。

所以所有的编译器、解释器都是从很小的改进空间开始，这也是我们现在选择的策略的原因，虽然有很多方式构建更快的解释器，但是会出现不易理解的问题，我们的侧重点在于理解解释器上。
