# 垃圾回收

考虑运行一下Monkey代码片段会发生什么事情：

```monkey
let counter = fn(x){
    if (x > 100){
        return true;
    } else {
        let foobar = 9999;
        counter(x+1)；
    }
};
counter(0)
```

显然在执行函数体 101 遍后它会返回一个 `true`，但是在最后一遍递归返回时候发生了许多事情：

第一件事执行 `if-else` 表达式条件：`x>100`，如果它的生成值不是真值，那么 `else` 分支将会被执行。在此之中的整型字面值 `9999` 将会绑定到标识符 `foobar`，而它从未被引用过。而是 `x+1` 被执行了，结果导致调用 `Eval` 函数被调用，并且调用 `counter` ，如此往复直至 `x>100` 判断为 `TRUE` 。

问题的关键是每一次调用 `counter` ，将会有许多对象被分配，或者将 `Eval` 函数的内容放入我们的对象系统。 每一次执行 `counter` 的函数体会带来`object.Integer`被分配和实例化，例如这些未被使用的 `9999` 整型和 `x+1` 的结果。甚至字面值 `100` 和 `1` 在每次执行 `counter` 的函数体时候也会产生新的 `object.Integer` 对象。

如果我们修改我们的`Eval`函数并且记录跟踪每一个 `&object.Integer{}` 实例，我们将会看到运行这个短小的代码实例差不多400多次的 `object.Integers`分配。

那么问题在哪呢？我们的对象存储在内存中，使用的对象越多，需要的内存越多。尽管例子中的对象的数量相对于其他程序非常少，但是内存不是无限的。每次调用`counter` 函数，我们解释器需要的内存就会增加，直至将内存全部用尽然后操作系统杀死这个程序。但是我们在运行上面的代码片段并对内存监控，发现它并不是持续上涨并且也不是下降。既不是上升也不是下降，这是为什么？
问题的答案就是我不得不讨论的：我们重用了 Go 语言额垃圾回收机制并且作为我们`Monkey` 语言的垃圾回收机制，这些我们不需要自己完成。Go 语言垃圾回收机制（GC）就是我们为什么不会用完内存的原因，它帮我们管理内存。尽管我们调用 `counter` 函数很多次，我们增加了很多未被使用的整型字面值和分配的对象，我们不会用光内存。因为 GC 记录每一个 `object.Integer` 是否仍然可达。当它注意到一个对象不可达后，它释放该内存使之可以再次使用。

上述的例子生成了很多整型对象，但是在调用 `counter` 后，它们都不再可达。字面值 `1` 和 `100` 同无意义的 `9999` 绑定的 `foobar` ，在 `counter` 返回后这些对象将不会可达。在上述例子中 `1` 和 `100` 很显然它不再可达，因为它们并没有绑定任何标志符。但是 `9999` 绑定的 `foobar` 不可达的原因是当函数返回时，它超出了作用域。为函数体执行而创建的环境也被销毁（这些都是 GC 完成的）。这些不可达的对象是不可达的并且占据着内存，这也是 GC 收集他们并且释放它们使用的内存。这些对我们来讲非常有用，帮助我们省下了很多工作。如果我们编写我们解释器使用C语言，在那里我们将不会拥有 GC，我们需要自己为解释器的用户实现内存管理。那么实现这个 GC 需要怎么做？简单来讲：记录每个对象分配和它的引用，留下足够的内存足够为将来对象的分配并且归还那些不在需要的对象的内存。最后最重要的一点是，如果没有这个机制，将会泄露内存并且最终用光内存。
有很多方法能够实现上述要求，包含了很多算法和实现。比如，有一种基础的“标记清除”算法。为了实现它需要考虑是 GC 是否为分代 GC ，是否为 STW 类型 GC 还是并行 GC，如何组织内存如何处理内存碎片。尽管考虑上述所有需求，高效的 GC 算法事项仍然需要很多工作。

你或许会问自己：**在这我们是使用 Go 语言的 GC，那我们能不能自己编写 GC 而不用 GO 语言的？**

不幸的是，不能这样做。我们需要禁用Go语言的GC并找到方法来接管它所有的工作。说起来容易做起来难。这是巨大的工作量，需要小心地考虑内存分配和释放问题。

这也是我决定在本书不增加**让我们编写我们的 GC 而不是 Go 的 GC**的小节而是重新使用 Go 语言的 GC。垃圾回收是一个巨大的主题并且超出了本书讨论的返回。但是我希望本小节给你 GC 大致映像以及它解决了什么问题，或许你知道了如果你想将这个解释器转移到其他宿主语言上需要考虑什么。不管怎样，我们的解释器完成了，剩下的就是拓展，增加一些数据类型和方法使之能够更加好用。
